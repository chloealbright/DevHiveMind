{
	"nodes":[
		{"id":"994b9d81037cb7c4","type":"group","x":5800,"y":399,"width":3060,"height":2362,"label":"Merging List"},
		{"id":"2e4f2058c518e9cb","type":"group","x":480,"y":840,"width":2120,"height":1480,"label":"Untitled group"},
		{"id":"8675754d1ace9424","type":"group","x":9040,"y":-2384,"width":2760,"height":2320,"label":"Dynamic programming"},
		{"id":"c46f5531386ed038","type":"group","x":3200,"y":-2384,"width":2600,"height":2320,"label":"Backtracking"},
		{"id":"40730cb7c8ad45e8","type":"group","x":-2880,"y":-2080,"width":2040,"height":2920,"label":"Search"},
		{"id":"dafe625fdcaa6bdc","type":"group","x":6320,"y":-2384,"width":2240,"height":2320,"label":"Sliding window"},
		{"id":"af497f0dfb13495a","type":"group","x":1200,"y":-2384,"width":1800,"height":2783,"label":"Pointer"},
		{"id":"0db2556051b59796","type":"group","x":3200,"y":263,"width":2179,"height":2057,"label":"Finding  Smallest or Largest Elements "},
		{"id":"7d3a292e4edef874","type":"group","x":-640,"y":-2080,"width":1640,"height":2600,"label":"Sorting"},
		{"id":"986759463ed39fa2","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Pointer Manipulation</h4>\n</center>\n\n","x":1320,"y":-1873,"width":1466,"height":368,"color":"3"},
		{"id":"7875257352e32714","type":"text","text":"# Fast slow is basically a variation of two pointer used for detecting cycles in two pointer","x":1760,"y":-1453,"width":533,"height":309},
		{"id":"26c526b16b714c0a","type":"text","text":"\n![[Key Base Attributes of  Grokking Algorithm patterns#Two Pointer |Two Pointer]] \n\n\n","x":1240,"y":-1388,"width":454,"height":314},
		{"id":"bc13b26f518aa299","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc2.png","x":596,"y":1632,"width":400,"height":257},
		{"id":"8a695e44195c85af","type":"text","text":"## Problem Statement phrasing used to Identify potential pattern","x":-440,"y":1040,"width":714,"height":498},
		{"id":"dae54ad49aa9ec97","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc448.png","x":475,"y":-528,"width":400,"height":246},
		{"id":"38b7ed365001f13c","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc268.png","x":475,"y":-916,"width":400,"height":291},
		{"id":"5599748caa5a7cf8","type":"text","text":"# [[Key Base Attributes of  Grokking Algorithm patterns#Cyclic Sort |Cyclic Sort]]","x":513,"y":-1129,"width":325,"height":90},
		{"id":"c5341d99fa7ac5bc","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Topological Sort]]","x":-532,"y":41,"width":814,"height":388},
		{"id":"b989aa10916de99d","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Fast & Slow Pointers |Fast Slow Pointer]]","x":2334,"y":-1381,"width":626,"height":237},
		{"id":"dcda9c3dcef382a3","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Reversing a Linked List |Reversing a Linked List]]","x":2027,"y":-1003,"width":709,"height":459},
		{"id":"e19264637f4761fe","type":"text","text":"# a dummy node is an artificial or placeholder node added to the list for various purposes, often to simplify edge cases or improve the efficiency of certain operations.","x":1360,"y":-964,"width":620,"height":344},
		{"id":"9287d7f5fc1ea5b2","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc1721.png","x":2182,"y":-342,"width":400,"height":383},
		{"id":"aaca24c0521f9659","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc1721ALT.png","x":1620,"y":-331,"width":400,"height":361},
		{"id":"3f5c84e1e2d80ce6","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Sort Algorithms </h4>\n</center>\n\n","x":-565,"y":-1569,"width":1480,"height":368,"color":"2"},
		{"id":"79167be838ed283c","type":"text","text":"## Add something for topological sort which is specifically for graphs","x":-85,"y":-593,"width":416,"height":300},
		{"id":"b488f7f1cb2f78d2","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Optimal Sorts </h4>\n</center>\n\n","x":-565,"y":-1129,"width":880,"height":150},
		{"id":"216ae97b8ef097ba","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/quicksort.png","x":-85,"y":-862,"width":399,"height":216},
		{"id":"ea2d6ab5a12b24df","type":"text","text":"```javascript\nfunction indexEqualsValueSearch(arr) {\n    let low = 0;\n    let mid = arr.length / 2;\n    let min = Infinity;\n\n    for (let start = 0; start < arr.length; ++start) {\n        if (arr[start] === start) {\n            min = Math.min(min, arr[start]);\n        }\n    }\n\n    return min === Infinity ? -1 : min;\n    // Check current index and value to see if they match and find the lowest matching value\n}\n```","x":-1668,"y":-930,"width":780,"height":525},
		{"id":"54ce953fba4f3920","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Linear Search </h4>\n</center>\n\n","x":-1618,"y":-1129,"width":480,"height":150},
		{"id":"c841a2ae62c2b4ff","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc704.png","x":-2360,"y":-917,"width":400,"height":292},
		{"id":"2459f85bc43b1ae7","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc744.png","x":-2360,"y":-539,"width":400,"height":187},
		{"id":"993171a88d1c6138","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/mergeSort.png","x":-565,"y":-884,"width":400,"height":259},
		{"id":"3afcf0a83a0845e5","type":"text","text":"# Add DFS and BFS for tree and graphs","x":-1397,"y":-160,"width":377,"height":201},
		{"id":"d37054d16ee85952","type":"link","url":"https://algo.monster/flowchart","x":-2605,"y":1760,"width":2125,"height":3481},
		{"id":"089443a65f001f43","type":"text","text":"##### Modified binary search is just a variation of the core binary search structure also default to while loop for this search","x":-2780,"y":-1054,"width":360,"height":374},
		{"id":"6f5c525180d5cafa","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Search Algorithms </h4>\n</center>\n\n","x":-2480,"y":-1580,"width":1480,"height":368,"color":"1"},
		{"id":"b09e420decafa819","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Optimization Patterns </h4>\n</center>\n\n","x":9280,"y":-2041,"width":1819,"height":368,"color":"5"},
		{"id":"98642a5104772367","type":"text","text":"Both expressions calculate the middle index of a range, but they are used in different contexts and for different scenarios.\n\n1. **`let mid = Math.floor((low + high) / 2);`**\n\n   This is the standard calculation for the middle index in a binary search or any situation where you want to find the midpoint of a range between two indices (`low` and `high`). This formula works well when you are dealing with the current range and want to split it into two halves.\n\n   ```javascript\n   let mid = Math.floor((low + high) / 2);\n   ```\n\n2. **`let mid = left + Math.floor((right - left + 1) / 2);`**\n\n   This formula is used in certain situations where you want to find the midpoint in a specific way. It is often employed in algorithms where you need to adjust the calculation to suit the problem's requirements. The `+1` in the formula ensures that the midpoint leans towards the right if the range has an odd number of elements.\n\n   ```javascript\n   let mid = left + Math.floor((right - left + 1) / 2);\n   ```\n\n   This might be used in scenarios where you are working with subarrays, or when you need to adjust the midpoint calculation for the specific requirements of a particular algorithm.\n\nIn summary, both formulas find the middle index of a range, but the second formula (`left + Math.floor((right - left + 1) / 2)`) is more specific and may be used in certain situations where the standard binary search formula might need adaptation for the problem at hand.","x":-2480,"y":-293,"width":658,"height":983},
		{"id":"c39e7d606352765d","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Binary Search </h4>\n</center>\n\n","x":-2400,"y":-1129,"width":480,"height":150},
		{"id":"3c04c53a128b891a","type":"text","text":"# Used for comparing range of elements next to each other ","x":7872,"y":-1365,"width":448,"height":216},
		{"id":"b675d7261c9bba2a","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Dynamic Programming]]","x":9560,"y":-1274,"width":840,"height":445},
		{"id":"b87e56d11a150d4e","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc3nw.png","x":6795,"y":-665,"width":1077,"height":520},
		{"id":"1f3da6aa99e9ff5e","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Sliding Window |Sliding Window]]","x":6795,"y":-1393,"width":1040,"height":619},
		{"id":"f934c03c7940f169","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Range Processing </h4>\n</center>\n\n","x":6561,"y":-1857,"width":1819,"height":368,"color":"5"},
		{"id":"5ffbc2cb21f1ccb2","type":"text","text":"# [[Dynamic Programming Pattern]]","x":9942,"y":-1505,"width":458,"height":105},
		{"id":"b8b0c34c19433cfa","type":"text","text":"# [[Knapsack Pattern]]","x":10588,"y":-1505,"width":511,"height":132},
		{"id":"3c4c48fca3bb1da1","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Knapsack Problem]]","x":10523,"y":-1274,"width":576,"height":434},
		{"id":"5da5bfee0690f377","type":"text","text":"## Keyword indicator \n**Dynamic Programming:** Keywords like \"optimal substructure,\" \"overlapping subproblems,\" or explicit mentions of finding the \"best,\" \"maximum,\" or \"minimum\" solution over a set of choices.","x":9889,"y":-708,"width":699,"height":268},
		{"id":"8a23eac4851dd237","type":"text","text":"Dynamic programming is a problem-solving technique used to solve optimization problems by breaking them down into smaller overlapping subproblems. The knapsack problem is a classic optimization problem that can be efficiently solved using dynamic programming.\n\nIn the context of the knapsack problem, dynamic programming involves solving smaller subproblems and using their solutions to build up the solution for the larger problem. The knapsack problem often has two variations: 0/1 Knapsack, where items can either be included or excluded, and Fractional Knapsack, where items can be divided.\n\nDynamic programming helps optimize the solution to the knapsack problem by avoiding redundant computations. By storing and reusing solutions to subproblems, dynamic programming ensures an efficient solution to the overall problem. This approach significantly improves the time complexity compared to naive recursive approaches, making it a powerful tool for solving various types of optimization problems, including the knapsack problem.","x":11200,"y":-1720,"width":459,"height":1509},
		{"id":"a3ed95bc6e5747ce","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Merge Algorithms </h4>\n</center>\n\n","x":6386,"y":580,"width":1819,"height":368,"color":"5"},
		{"id":"8168d5c760f807a7","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc986.png","x":6545,"y":1050,"width":1275,"height":487},
		{"id":"70b42aa53a799b1a","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Merge Intervals]]","x":6820,"y":1600,"width":885,"height":447},
		{"id":"241d1f208b414dee","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#K-Way Merge]]","x":7820,"y":1600,"width":900,"height":447},
		{"id":"2014bccb5492caa0","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\"> Element Selection </h4>\n</center>\n\n","x":3360,"y":682,"width":1819,"height":368,"color":"5"},
		{"id":"d48c234c57a6a567","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Top K Elements]]","x":3712,"y":1214,"width":788,"height":586},
		{"id":"0d4345a71bba6971","type":"file","file":"Algorithms & Data Structures/_Infographic/Patterns path.png","x":1760,"y":2960,"width":6240,"height":3501},
		{"id":"e69057eef2914fe4","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Backtracking/Subset </h4>\n</center>\n\n","x":3560,"y":-1857,"width":1819,"height":368,"color":"5"},
		{"id":"e967e089016e94ad","type":"text","text":"#### Function Structure:\n\nThis structure allows you to explore different paths in a matrix or graph, checking right, left, down, and up directions. It keeps track of visited positions and backtracks as needed.\n\n#### Additional Techniques:\n- You can use closure to create a function that takes in a matrix and returns an inner function with parameters for the current row and column values.\n- You can start the traversal from different roots in the matrix depending on your problem requirements.\n- The order of traversal can vary depending on the problem and can be customized to suit your needs.","x":4627,"y":-1327,"width":752,"height":718},
		{"id":"64266aa511d2f43f","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/Backtrack Robo Path.png","x":4172,"y":-1258,"width":399,"height":269},
		{"id":"e8f5daa45271cd68","type":"text","text":"# [[Key Base Attributes of  Grokking Algorithm patterns#Subsets/Backtracking |Backtracking]]","x":4172,"y":-1423,"width":343,"height":116},
		{"id":"26831e9333011dd0","type":"text","text":"The reason why **\"Access\"** should be included, even though it's a subset of **\"Reads\"**, lies in the nuanced requirements of certain problems. While performing tasks like searching or implementing conditional logic, you may indeed engage in **\"Access\"** operations. However, when addressing traversal-related challenges, a full traversal of a specific data structure or path might not always be necessary. In scenarios like backtracking problems, you might find that performing a sub-action like **\"Access\"** suffices. For instance, consider a problem where you need to traverse a matrix in a **spiral** manner. In such cases, you're primarily accessing adjacent elements without necessarily reading the entire matrix. Therefore, including **\"Access\"** as a separate category of actions ensures comprehensive coverage when analyzing and solving problems. 🌀🔍","x":3465,"y":-935,"width":575,"height":831},
		{"id":"d2f61c51528b4017","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc904.png","x":1916,"y":920,"width":363,"height":400},
		{"id":"024d6f69002962f1","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/treeStruc.png","x":1116,"y":1432,"width":192,"height":400},
		{"id":"b475b69ad0b48a91","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc49.png","x":917,"y":1955,"width":399,"height":256},
		{"id":"3c0afbd524e9bc10","x":1600,"y":1451,"width":826,"height":564,"type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/Linked List to Tree to Graph.png"}
	],
	"edges":[
		{"id":"87b81ddd507e6712","fromNode":"26c526b16b714c0a","fromSide":"right","toNode":"b989aa10916de99d","toSide":"left"}
	]
}