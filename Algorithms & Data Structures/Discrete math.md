---
tags:
  - programming
author:
  - jacgit18
Status: done
Started: 
EditDate: 
Relates:
---
The nature of Discrete Math 1 and 2 courses can vary significantly based on the professor teaching them. In my experience, the first part of the course delved deeply into mathematical concepts but transitioned into a more computer science-focused approach in the latter stages, involving numerous programming assignments, especially in Exam 3.

Key takeaways from Discrete Math 2 should encompass knowledge of graphs, trees, divide and conquer algorithms, stacks, queues, and hash tables. It should also include familiarity with advanced algorithms, a deeper understanding of Big O notation, and perhaps discussions on memory management. By the end of Discrete Math 2, you should be as well-versed in these topics as you are in the fundamental concepts learned in Discrete Math 1, such as sorting, logic principles, and the essential mathematical foundations for algorithm development.

Consider Discrete Math 1 as a stepping stone for Discrete Math 2. The first course sets the groundwork to propel you into more advanced concepts.

If your professor has practical industry experience, they might structure the course to reflect real-world challenges. Some of the problems you encounter could mirror issues faced in their own work, such as sorting problems related to financial trades. This practical approach is valuable.

On the other hand, if your professor is primarily a mathematician with a penchant for computer science research, the course may have a 70/30 split between mathematical and computer science content, which can be quite enriching.

If you find yourself with a professor deeply rooted in mathematics, expect a more theoretical course. While this might not always directly apply in the professional world, it will provide a solid foundation for algorithm development and programming.

Each teaching style has its advantages and disadvantages. I, for instance, have a strong mathematical inclination but work as a software engineer, so I strive to infuse my teaching with practical insights.



***Additionally, here are the suggested projects for both Discrete 1 and 2:***

**List of Suggested Projects for Discrete 2:**

1. **Lecture 1:** Explore Ackermannâ€™s Function (Section 5.3, P. 359, Exercise 48-55).
2. **Lecture 2:** Dive into the QuickSort Algorithm (Section 5.4, P. 371, Exercise 49-52).
3. **Lecture 9:** Tackle a variation of the Towers of Hanoi Game (Section 8.1, P. 512, Exercise 32).
4. **Lecture 9:** Solve the Josephus Problem (Section 8.1, P. 512, Exercise 33-37).
5. **Lecture 11:** Explore Lucas Numbers (Section 8.2, P. 525, Exercise 11).
6. **Lecture 15:** Code graphs, including nodes and edges, in a programming language (e.g., Python, C++, or Java).
7. **Lecture 22:** Develop code for Family Trees and Boolean functions that check relationships between family members.
8. **Lecture 23:** Create code for Binary Search Trees (e.g., in Python, C++, or Java).
9. **Lecture 28:** Write a recursive algorithm to compute the height of any tree, for example, a binary search tree.

**List of Suggested Projects for Discrete 1:**

1. **Lecture 21:** Time algorithms based on input size.
2. **Lecture 23:** Experiment with Primality testing using a programming language.
3. **Lecture 24:** Implement a hashing function and a pseudorandom generator in a programming language.
4. **Lecture 25:** Develop an implementation of a Caesar cipher.
5. **Lecture 27:** Create a Tower of Hanoi game.






