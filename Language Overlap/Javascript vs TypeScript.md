---
tags:
  - languageOverlap
author:
  - jacgit18
  - chatgpt
Comments: This documentation discusses JavaScript and typescript relationship.
Status: Done
Started: 
EditDate: 2024-03-02
Relates:
---
![[java-script Inner Working.gif]]

### Evolution of JavaScript and Its Versatility

JavaScript, initially conceived for enhancing website interactivity, has evolved far beyond its origins, thanks in part to the introduction of the V8 engine by Google Chrome. The V8 engine expanded JavaScript's utility, enabling its application in mobile, desktop, and server development.

### Weak Typing in JavaScript and Strong Typing in Java

JavaScript is often characterized as a weakly typed language, providing flexibility in variable declaration without explicitly specifying types. In contrast, Java is considered strongly typed, requiring explicit type declarations and additional details such as access modifiers (private/public) when defining variables and functions. However, with TypeScript, a superset of JavaScript, developers can introduce strong typing to enhance code robustness.

### JavaScript Modules and TypeScript's Role

JavaScript files can be treated as modules, encapsulating code to promote modularity and maintainability. This modular approach allows for organized code structure and better code reuse. TypeScript, with its support for modules and strong typing, further enhances the organization and readability of JavaScript codebases.

### Memory Allocation and Garbage Collection

In the execution of JavaScript, the process involves memory allocation, parsing, and execution. Memory allocation includes declaring variables and assigning values. Notably, unused variables, especially global ones, can contribute to memory leaks. JavaScript, being a garbage-collected language, automatically manages memory. Garbage collection ensures that unused variables are identified and released, preventing memory bloat and enhancing the efficiency of the overall application.

### TypeScript: Enhancing JavaScript with Types

TypeScript stands as a superset of JavaScript, introducing a robust type system to the language. This means that TypeScript extends the capabilities of JavaScript by incorporating additional features, particularly in the realm of type safety.

### Transpilation: Bridging TypeScript to JavaScript

In the process of software development, TypeScript code undergoes transpilation, a mechanism that translates it into JavaScript code. This conversion ensures compatibility with web browsers, as they execute JavaScript. The tool responsible for this transformation is the TypeScript compiler (`tsc`), which takes TypeScript code as input and generates equivalent JavaScript code as output.

### Preprocessing and ECMAScript Compatibility

The transpilation process can be likened to preprocessing, where TypeScript acts as an intermediary layer between the developer and the JavaScript executed by browsers. This intermediate step allows developers to leverage advanced language features while ensuring compatibility with ECMAScript, the standard upon which JavaScript is based.

### TypeScript Compiler (`tsc`): Facilitating the Conversion

The TypeScript compiler (`tsc`) plays a crucial role in this conversion, handling the translation of TypeScript code into JavaScript. The resulting JavaScript code is then executed by web browsers, enabling developers to utilize TypeScript's features without sacrificing compatibility with the widely supported JavaScript runtime environment.

The transpiled JavaScript code can be executed in a web browser like any other JavaScript code. The browser does not interpret TypeScript; it executes the plain JavaScript code generated by the TypeScript compiler.  
  
While TypeScript types are removed during transpilation, they are still valuable during the development phase. TypeScript's type checking helps identify type-related issues before the code reaches the browser, improving code quality and reducing runtime errors.  

TypeScript types are mainly a development tool for enhancing developer productivity, reducing errors, and providing better code documentation. They do not affect the actual runtime behavior of the JavaScript code in the browser.  

# Execution Context

![[Global Exe Context.png]]![[javascript Scope inDeph.png]]

### Components of Execution Context

The Execution Context encompasses crucial elements that shape the behavior of code execution:

#### 1. Lexical Environment {Scope}

The Lexical Environment consists of the general scope block, which includes both global and function scopes. This environment dictates the visibility and accessibility of variables within the code.

#### 2. Variable Environment

The Variable Environment is responsible for evaluating the values of created variables. It operates independently of binding and focuses on managing variable values within the execution context.

#### 3. "this" Binding

The "this" Binding is a reference that points to different objects depending on the execution context. In the global context, "this" typically refers to the window object, while within functions, it may vary based on how the function is invoked.

#### 4. Window Object

The Window Object serves as a container for multiple "this" references, each pointing to different prototypes. Understanding the hierarchical structure within the window object is crucial for comprehending the dynamic nature of "this."

### Global Execution Context

The Global Execution Context establishes the foundation for code execution at a global level. It involves two key processes:

#### - Memory Heap

A Memory Heap is created to store all variables and functions at a global level. This heap serves as a repository for the global code's entities.

#### - Global Object and "this" Keyword

The Global Object, along with the associated "this" keyword, is instantiated. The location and reference of "this" are contingent on the runtime environment. In a browser, "this" points to the window object, whereas in Node.js, it aligns with a distinct global object.

Understanding the dynamics of the Execution Context, including its lexical environment, variable environment, "this" binding, and global execution setup, provides insights into how JavaScript code is structured and executed across different environments.


![[Functions behind scenes.png]]

call(), apply() and bind() 

Up until now we have treated functions as objects that are composed of a name (optional, can also be an anonymous function) and the code it executes when it is invoked. But that isn’t the entire truth. As a truth loving person, I must let you know that a function actually looks closer to the following image: 

bind() 

The official docs say: The bind() method creates a new function that, when called, has its this keyword set to the provided value. (It actually talks about even more stuff, but we’ll leave that for another time :) ) 

This is extremely powerful. It let’s us explicitly define the value of this when calling a function. 

When we use the bind() method: 

the JS engine is creating a new pokemonName instance and binding pokemon as its this variable. It is important to understand that it copies the pokemonName function. 

After creating a copy of the pokemonName function it is able to call logPokemon(), although it wasn’t on the pokemon object initially. It will now recognizes its properties (Pika and Chu) and its methods. 

And the cool thing is, after we bind() a value we can use the function just like it was any other normal function.  

call(), apply() 

The official docs for call() say: The call() method calls a function with a given this value and arguments provided individually. 

What that means, is that we can call any function, and explicitly specify what this should reference within the calling function. Really similar to the bind() method! This can definitely save us from writing hacky code (even though we are all still hackerzzz). 

The main differences between bind() and call() is that the call() method: 

Accepts additional parameters as well 

Executes the function it was called upon right away. 

The call() method does not make a copy of the function it is being called on. 

call() and apply() serve the exact same purpose. The only difference between how they work is that call() expects all parameters to be passed in individually, whereas apply() expects an array of all of our parameters.  

var pokemon = { 

    firstname: 'Pika', 

    lastname: 'Chu ', 

    getPokeName: function() { 

        var fullname = this.firstname + ' ' + this.lastname; 

        return fullname; 

    } 

}; 

var pokemonName = function(snack, hobby) { 

    console.log(this.getPokeName() + ' loves ' + snack + ' and ' + hobby); 

}; 

pokemonName.call(pokemon,'sushi', 'algorithms'); // Pika Chu  loves sushi and algorithms 

pokemonName.apply(pokemon,['sushi', 'algorithms']); // Pika Chu  loves sushi and algorithms




Debugging Memory Leaks 

In JavaScript, memory leaks commonly occur within heap allocated memory, where short lived objects are attached to long lived ones and the Garbage Collector cannot safely de-allocate that memory as it is still referenced from the root set (the global object).




Strict Mode 

JavaScript's strict mode is a way to opt-in to a restricted variant of JavaScript, thereby implicitly opting out of "sloppy mode". Strict mode isn't just a subset: it intentionally has different semantics from regular code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist so that scripts can opt into strict mode incrementally. 

Strict mode makes several changes to normal JavaScript semantics: 

-   Eliminates some JavaScript silent errors by changing them to throw errors. 
    
-   Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes run faster than identical code that's not strict mode. 
    
-   Prohibits some syntax likely to be defined in future versions of ECMAScript.





Production Build & Compiling 

There are some other useful topics as compiling and creating production build. After you successfully build your application it would be ready to use in production! Compiling your typescript code will convert it to regular vanilla JavaScript code. 

To be able to compile your code to JavaScript you can use the script below 

"build": "tsc --project ." 

That will build your code into the dist folder as we specified in the tsconfig.json file. You can check out that file and it will be similar to this app.js file. 

import express from 'express'; 

const app = express(); 

const port = 8000; 

app.get('/', (req, res) => { 

res.send('Hello world!'); 

}); 

app.listen(port, function () { 

console.log(`App is listening on port ${port} !`); 

}); 

You can start using this code in production now! 

To be able to make always clean build you can use the command below 

"build": "rm -rf ./dist && tsc --project ." 

That will remove the dist folder already created in another build and create a new build. 

Running the production build code on your localhost is very easy after these steps are completed. 

There is another script we should add to package.json file to be able to run the production build in localhost. 

"start:prod": "yarn build && node ./dist/app.js" 

That command will create a new production build and start running it from the dist folder. 

That is all that is required to set up Express application with TypeScript and using ES modules in the Node application!