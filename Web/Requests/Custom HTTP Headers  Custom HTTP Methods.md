---
tags: 
author:
  - jacgit18
Status: 
Started: 
EditDate: 
Relates:
---
### When and How to Use Custom HTTP Headers


It is not uncommon to find HTTP servers using custom headers. Some well-known custom headers include X-Powered-By, X-Cache, X-Pingback, X-Forwarded-For, and X-HTTP-Method-Override. HTTP does not prohibit such extension headers, but depending on what clients and servers use custom headers for, custom headers may impede interoperability. This recipe discusses when and how to use custom HTTP headers. 

Use custom headers for informational purposes. Implement clients and servers such that they do not fail when they do not find expected custom headers. 

Avoid using custom HTTP headers to change the behavior of HTTP methods. Limit any behavior-changing headers to the method POST. 

If the information you are conveying through a custom HTTP header is important for the correct interpretation of the request or response, include that information in the body of the request or response or the URI used for the request. Avoid custom headers for such usages. 

Most websites using the WordPress blogging platform (http://wordpress.org) include the following HTTP headers in responses: 

X-Powered-By: PHP/5.2.6-2ubuntu4.2 

X-Pingback: http://www.example.org/xmlrpc.php  

Such headers are not part of HTTP. The first header is generated by the PHP runtime that WordPress is built on. It indicates that the server is using a particular version of PHP on Ubuntu. The X-Pingback header contains a URI that clients can use to notify WordPress when a reference is made on some other server to the resource. Similarly, HTTP caching proxy Squid uses X-Cache headers to inform clients whether the representation in the response is being served from the cache. 

Such usages are informational. Clients receiving those headers are free to ignore them without loss of functionality. Another commonly used informational header is X-Forwarded-By. 

X-Forwarded-For: 192.168.123.10, 192.168.123.14  

The purpose of this header is to convey the source of the request to the server. Some proxies and caches add this header to report the source of the request to the server. In this example, the server received a request from 192.168.123.10 via 192.168.123.14. If all proxies and caches that the request is served through augment this header, then the server can determine the IP address of the client. 

The following custom HTTP headers are not informational and may be required for the correct processing of requests or responses: 

# A version number of the resource 

X-Example-Version: 1.2 

# An identifier for the client 

X-Example-Client-Id: 12345 

# An operation 

X-Example-Update-Type: Overwrite 

Avoid such usages. They weaken the use of URIs as resource identifiers and HTTP methods as operations. 

Another commonly used custom header is X-HTTP-Method-Override. This header was initially used by Google as part of the Google Data Protocol ([http://code.google.com/apis/gdata/docs/2.0/basics.html](http://code.google.com/apis/gdata/docs/2.0/basics.html?authuser=1)). Here is an example: 

# Request 

POST /user/john/address HTTP/1.1 

X-HTTP-Method-Override: PUT 

Content-Type: application/xml;charset=UTF-8 

<address> 

  <street>...</street> 

  <city>...</city> 

  <postal-code>...</postal-code> 

</address>  

In this case, the client uses X-HTTP-Method-Override with a value of PUT to override the behavior of the method used for the request, which is POST. The rationale for this extension was to tunnel the method PUT over POST so that any firewalls configured to block PUT will permit the request.



### When to Use Custom HTTP Methods

Avoid nonstandard custom HTTP methods for compatibility with off-the-shelf software. Design a controller resource for abstract operations and utilize the standard HTTP method POST.

- **WebDAV Methods**: WebDAV defines methods like PROPFIND, PROPPATCH, MOVE, LOCK, UNLOCK for distributed authoring and versioning.

- **Other Examples**: PATCH for partial updates, MERGE for resource merging.

- **Considerations**: Nonstandard methods are treated similarly to POST by proxies, caches, and HTTP libraries. Server-provided idempotency and safety guarantees are essential. Use custom methods only when interoperability is not a concern.