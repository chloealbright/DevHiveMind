Discrete Math 1 and 2 explained by professor 

It genuinely depends on the professor teaching it.  The first half of my course was very intensely mathematical but transformed into more of a CS class in the later stages with a lot of programming assignments.  Exam 3 was particularly very program-heavy. 

The key takeaways from Discrete II should be graphs, trees, divide/conquer algorithms, stacks, queues, and hash tables, some advanced algorithms, advanced big O, and maybe some discussion on memory management. By the end of discrete 2, you should know that just as well as you know the key takeaways from discrete I, such as sorting, logic principles, the underlying/important conceptual underpinnings of mathematics, and how to write basic algorithms/basic algorithmic development.  Discrete I is there to springboard you straight into Discrete II. 

If your professor has worked in the industry like me, then he'll fashion the course similarly to how I did.  Some of the problems I gave you guys were issues that I had to deal with at work (given a set of trades, "find the trades with $1B notional principal that go by a LIBOR floating interest rate and are Forward Rate Agreements."  This is a sorting problem!).  So, he/she will most likely do that if they work/worked in the industry. 

On the other hand, if they're a mathematician who indulges in CS research, then you'll probably get a course that is 70/30 math/CS, which is a nice split too. 

If you're dealing with a mathematician through and through, you'll be looking into a very theoretical course.  In other words, expect some deep mathematical thinking and theory building.  In the work world, this might not always be something you'll think about on the fly, but it will give you an exceptionally solid basis from which you can develop algorithms and write programs. 

Each style has its pros/cons.  I'm personally very mathematically minded, but I work as an SWE so I try to use that experience to inform my teaching. 

Any further questions, feel free to email.  Also, note that there is no particular order you can/should follow.  Jump straight into whatever topic you find interesting and if you need prereqs, you can easily find 'em online.




List of Suggested Projects Discrete 2 

1. Lecture 1: Ackermann’s Function (Section 5.3, P. 359, Exercise 48-55) 

2. Lecture 2: QuickSort Algorithm (Section 5.4, P. 371, Exercise 49-52) 

3. Lecture 9: A variation to the Towers of Hanoi Game (Section 8.1, P. 512, Exercise 32) 

4. Lecture 9: The Josephus Problem (Section 8.1, P. 512, Exercise 33-37) 

5. Lecture 11: Lucas Numbers (Section 8.2, P. 525, Exercise 11) 

6. Lecture 15: Coding Graphs (nodes and edges) in a programming language (e.g. Python, C++, or Java) 

7. Lecture 22: Coding Family Trees, and Boolean functions checking relationships between family members 

8. Lecture 23: Coding Binary Search Trees (e.g. in Python, C++, or Java) 

9. Lecture 28: Coding a recursive algorithm that computes the height of any tree; for example, a binary search tree. 



List of Suggested Projects Discrete 1 

2. Lecture 21: Timing algorithms by input size. 

3. Lecture 23: Primality testing using a programming language. 

4. Lecture 24: Implement a hashing function and a pseudorandom generator in a programming language. 

5. Lecture 25: Implement a Caesar cipher. 

6. Lecture 27: Implement a Tower of Hanoi game.