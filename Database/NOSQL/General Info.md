Non-Relational databases is used for unstructured data 

NoSQL is an umbrella term, one which encompasses a number of different technologies. These different technologies aren't even necessarily related in any way beyond the single defining characteristic of NoSQL: they are not relational in nature. This lack of relational structure results in unstructured or semi-structured data in storage; there may be structure, but it is loose in nature, lax in enforcement. 

Often, NoSQL is used to mean "not only SQL," meaning that these solutions are more flexible and less rigid in nature. I'm sure there are die-hards in this argument of terminology ownership, but just be aware of the potential difference in definition 

Some NOSQL DB don't have transactions which generally doesn't use tables or SQL but there are some that do when it at least comes to SQL besides that it NOSQL generally doesn't require a fixed schema but It can vary depending on what no SQL DB is used


![[_Images/Database/GetImage (12).png]]


## CAP
stands for **Consistency, Availability,** and **Partition** tolerance. And it states, we can only have two out of three of those items. 

**Consistency** here means that, data throughout the system is the same. It's when accuracy is of highest importance, so you're going to think banking, high-stakes transactions, maybe online deposits to your checking account. Availability relates to users being able to write and read the data regardless of failures in the network. And finally, partition tolerance means that the system is up and running, working as expected even if some of the network is down. Because we can only choose two out of these three very important factors, CAP Theorem helps us form intelligent decisions when choosing the right database for our needs. Relational databases, overall don't offer partition tolerance, nor do they offer high availability because they keep records that beta other users during updates. They do offer reliable, consistent data though. NoSQL databases offer partition tolerance, along with subspecialties related to availability or consistency in general, depending on the specific NoSQL database chosen. So relational databases offer extreme consistency but since data is found on only one machine generally, the partition tolerance suffers again. Also, because such systems lack records during updates, the availability isn't very high. Let's look at NoSQL systems that focus on partition tolerance and availability. How these systems work, is that all users can write to machine one in this case, but they read from machine two, three, four, et cetera. The consistent most accurate data here is on machine one. But the data, only makes it to the other machines in the systems after replication. Therefore, although there could be imperfect consistency in data, eventually as the machines that replicate data, the idea is that they will be consistent. So, they will have eventual consistency. Examples of such systems include CouchDB, Cassandra, and DynamoDB. Now, let's look at NoSQL systems that focus on partition tolerance and consistency, or CP systems. In this case, users read and write to machine one, and then replication occurs. The consistent, most accurate data here is on machine one. This data only makes it to the other machines in the system, after replication. Examples of such systems include MongoDB, Hbase, and Redis, along with relational databases with fail over. 

The first thing I want you to understand very clearly is that NoSQL is an umbrella term that describes a variety of non-relational databases. These are alternatives to traditional databases and there are four main types of these NoSQL databases. These four types differ from each other. Before we look at the differences between NoSQL types, let's look at some of the commonalities. NoSQL was developed to handle the LinkedIns, the Facebooks, Twitters, and Amazons of the world. These modern web applications need something that is scalable, always on. They need to handle a ton of data and data that isn't always neat and tidy. So they need to handle unstructured data. There are four main types of NoSQL databases. These include **key-value, document, wide-column,** and **graph**. In this module, we'll investigate these four types from a high-level perspective. Depending on your specific need, one might be better than another, and we'll investigate these specialties throughout the remainder of this chapter. 

**key value** stores are simple ways to store unstructured data for fast retrieval. Key and value can be anything. It's great for storing large amounts of data for simple querying. It's useful for things like caching and user preference storage. And if you're a developer, you can think of these as hash maps, dictionaries, et cetera. Some popular use cases according to Redis include caching for faster performance, session management, leaderboards, real-time inventory systems, fraud mitigation, and claims processing. Popular systems for key value databases include Redis, DynamoDB, and Oracle NoSQL amongst others. In Redis, this operation sets a given key and value. It's extremely simple to program. 

**Document databases** are similar to key value databases, but the value in this case is stored as a document. For example, the popular document database MongoDB stores the document in a format called BSON. It stands for binary JSON, and as you might suspect, it's very similar to JSON. In fact as a developer, just think of it as JSON. The values within a document can be all sorts of types, from strings to objects, arrays, et cetera, akin to how developers type variables in their code. So it makes it very flexible and useful for agile development, and you should choose it when you need a ton of flexibility, but not a lot of complex queries. Document stores are considered general purpose in a way, Swiss Army knife types of no SQL databases, and they're useful for a wide variety of needs. They're often used for CMS systems, large document storage, websites, they're also useful in user profiles, as well as real time analytics and big data. Popular document storage systems include Apache's CouchDB, MongoDB, and Azure Cosmos DB. Finally, here's an example query in the document database MongoDB. You'll notice it's very similar to JSON syntax, making it simple and flexible for developers to work with. 

**wide-column** stores, or column family databases, are a subset of key-value NoSQL databases. They're like relational databases in some ways because they use tables, rows, and columns, but unlike relational, these dynamic columns can vary from row to row, so they're very different in that sense. Also, unlike relational databases, tables can be created, altered, even dropped, while the database is running. It's best to use these when you know the queries and model your tables around queries, instead of how we would do it in relational database modeling, where you're modeling your tables around the data. Wide-column stores can be used for very fast querying of specific parts of data, but not whole rows. So you have to really understand what you're going to be querying before you build this thing out because it can go really fast, but it is very specific on how you query, typically using primary keys and indexes. Overall, wide-column databases are great for dealing with extremely large amounts of data where speed is of utmost importance. It's great for big data when you're looking fast searching over huge amounts, like petrabytes of data, inventory management, and even analytics systems. Those are also popular use cases. A couple popular document databases include **Cassandra** and **HBase**. You'll probably run into those more often than any other. And let's look at this, this is what a wide-column NoSQL query looks like in Cassandra. This is Cassandra query language, CQL, not to be confused with SQL. Well, let's look at the bonus table. See, that's a table there. Note that the database model design is focused on the user's bonus, that query, versus the data as would be in a relational database management system. And the second example here shows a query in CQL, and if you're familiar with SQL, you'll notice the similarity there. Update customer set branch equals main dot dot dot, right? Very similar to SQL. 

 **graph databases** happen to be my favorite type of NoSQL data store. And that's because they are so different than the other types. I mean, everything is stored in the form of an node or an edge that shows relationships between the nodes or attributes. And they are great when you want to show multidimensional relationships between different sets of data. Not so great when you want something general purpose though. So because they're relational nature, they're really well-suited for social networks where entities and their relationships are represented. Other use cases include fraud detection, recommendation engines. Some popular graph databases include Neo4j and JanusGraph. And cipher is Neo4j's graph query language. It allows users to store and retrieve data from the graph databases. And if you see here, it is a very good visual representation of what's happening and that's what the creators have tried to do here. They've made it intuitive from a visual perspective. 

 So first up, we have social networking. We're creating a site, we want to traverse relationships between users, their actions and the like. Which NoSQL database might be right in this scenario? Remember the four that we discussed. We have wide-column, document, key-value, and graph. Next, we want a leaderboard. So you have a game site, large amounts of data, and you want a really simple look query to show a leaderboard. Which of the four types might be suitable here? Next, this scenario, we have huge, huge, huge amounts of data, and we already know what the queries are going to look like. And you can model your data around the queries. which NoSQL solution seems appropriate given this scenario? And finally, we're creating a large CMS system. It's a general purpose kind of CMS, wide variety of data types. Which NoSQL database might likely be appropriate here? Okay, join on in for the next video. We're going to discuss the solution. 

The common jobs for each type of NoSQL store. So what we did is we looked at a bunch of scenarios for NoSQL databases and tried to figure out which of the four types would be right for a certain scenario, or mostly right for a certain scenario. So the first one was social networking. And the social networking site where we need to traverse relationships quickly is best for a graph database. A graph database where we have nodes and edges and we have relationships stored there. So that's the answer there. Next step, did you get key-value for the leaderboard? Because we're looking at some really simple, fast queries, right? Keys, values, user score, right, to create a leaderboard here. So key-value database would typically be the best solution for a leaderboard with simple data. Now, next up, this might've been a little confusing. Large amounts of data should have really set off an alarm for you in known queries. When you have huge amounts of data in these known inquiries, a wide-column is typically the best solution in this scenario. And finally, we have our CMS. General purpose, we need some variety of general data types. Typically document stores are best in this scenario. 

Only NoSQL databases offer this along with subspecialties generally related to availability or consistency depending on the NoSQL database chosen. The promise of partition tolerance means our whole system won't go down even if part of it does. And some scenarios lend themselves very well to this. For example, NoSQL's great for caching information. So users experience websites as running faster. Another place where NoSQL thrives is storing user session information. Again, it's information that's needed for a particular time period, but doesn't need to be stored perfectly everywhere at the same time. It's not a big consistency thing, right? If a user's session information isn't consistent it's not the end of the world. It's more important to us that our application is running for all users even if some of the data isn't perfect at any given moment. Real time inventory systems, fraud systems are two additional areas where NoSQL works well. Think about it. Is it more important that the data is perfect in these systems, or that the system is up and running at scale? I'd argue that consistency can be traded for partition tolerance here. I want my fraud detection system running. Even if some nodes might have imperfect data from time to time. 

In general, NoSQL fails where you need consistency of data and I'm not referring to eventual consistency or even consistency for some users but the most accurate consistency. What are some use cases that fit this bill? Well, I'm pretty certain that any of us would be tremendously upset if our banking system wasn't consistent. What do you mean, bank, I have $10,000 in that account? You're seeing a negative balance? That doesn't fly for me. If you need your data to be consistent and really cannot tolerate trade-offs in this area then a relational database is most likely the right solution for you. On top of these super important data consistency transactions, If you have a need for complex SQL queries or if you have developers with strong SQL chops then NoSQL might not be the right fit. You might want to look at relational there. Sometimes you just have these small systems like I have a pet project for example or a small internal project. Maybe I don't need partition tolerance in this scenario then again relational might be the correct solution for you. In short, there's no one size fits all. Choose the right system based on your needs. Do you absolutely need accurate, consistent data? If so then a relational database might be right for you. Otherwise, take a look at some of your options with NoSQL databases.

![[GetImage (13).png]]

 Let's assume that a NoSQL solution is right for you. Now, which database should you choose? In chapter two, we learned the different types of NoSQL databases, key-value, document, wide-column and graph and this is where we'll begin. First, you'll want to determine if you're looking for the fast and simple key-value solution, a general-purpose document solution, a solution for vast amounts of data with pre-defined queries or if you're looking for the relationship-specific graph database. Now that you know which NoSQL data store type could be appropriate, let's add on CAP theorem. And the two out of the three most important factors you face. So you're looking for consistency and partition tolerance. In that case, MongoDB, HBASE or Redis might be appropriate. Redis is key-value and CP. Mongo is document and CP. And HBASE is wide-column and CP. Similarly, if you're looking for availability in partition tolerance, you might consider CouchDB, Cassandra, or DynamoDB depending on the NoSQL data store type that is appropriate. Popularity of a NoSQL solution generally corresponds to the amount of talent that knows the specific technology. So let's use the previous table and add on popularity rankings. You'll notice here that MongoDB is number one in this list for document CP types of databases. It could be a good choice for you. The right NoSQL database for your needs can be determined by storage type qualities you're looking for. This, along with the two most important CAP factors, be it CP, CA or AP and the popularity of the database will give you a really strong start. Finally, you'll want to look at your developer's preference, along with costs associated for any particular database solution you're looking at.




Unlike relational databases, NoSQL databases do not have a standard schema. NoSQL databases are designed to be schema-less, which means that the structure of the database can be flexible and dynamic. However, there are certain patterns and approaches to modeling data in NoSQL databases that can be considered as schemas. Here are some common schema patterns for NoSQL databases: 

Key-Value Schemas: Key-value databases store data as simple key-value pairs. Each value is associated with a unique key that can be used to retrieve the data. This schema is simple and flexible, and is often used in caching and high-performance applications. 

Document Schemas: Document databases store data as documents, which are collections of key-value pairs or other structured data types such as arrays or nested objects. This schema is flexible and allows for complex data structures, making it popular in content management systems and other applications where data is unstructured. 

Column-Family Schemas: Column-family databases store data in column families, which are groups of columns that are stored together. This schema is designed for high-write throughput and allows for efficient querying of large datasets. 

Graph Schemas: Graph databases store data as nodes and edges, with nodes representing entities and edges representing relationships between them. This schema is used in applications that require complex relationship modeling, such as social networks and recommendation engines. 

These are just a few examples of schema patterns used in NoSQL databases. NoSQL databases allow for flexible and dynamic data modeling, which can be an advantage in certain applications where the structure of the data is constantly evolving.
