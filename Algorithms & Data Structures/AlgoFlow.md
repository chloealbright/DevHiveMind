---
tags:
  - codeFlow
  - editMerge
author: jacgit18
---
![[2023-10-24 16.03.28 miro.com 54a50b4177fe.png]]
When reading documentation about a Framework, Library, language, technology, or new features always learn about why something was created.  

algo design 

## Coding Styles

-   [[Declarative Coding]]
    
-   [[Imperative Coding]]

![[paradigms.png]]

    
-   Code example: 
    
    -   add function that iterates through an array and the elements and return the sum  
        
-   Vs 
    
    -   just returning an array.reduce and adding elements lesser steps then other and is more abstract  
        
    
-   Keep scope in mind  
    
    Solve the right problems and pay attention to the scope of the problems and how they affect the greater scope of the world or your world 
    
    using precision when it comes to scope is good to learn about specific things  but again when it comes to precision you are focus on a specific scope of element of that scope 
    
    but when you blunt you are less precise but can experience things and get a general feel  
    
    this why you can't use one tool for everything you need to learn how use and alternate between being blunt and precise in your approach



### Storing Data in data structures

In Data structures we can use [[Dictionaries]] and [[Hashmap]] to store things in memory so we do have to use nested for loops especially when trying to find values in an array that show up multiple times basically keeping track of the count  
  
  
O(n^2) Bubble shorts run to the left multiple times switching the highest to the lowest until the list is ordered.  
  
Selection sort switches numbers at a certain position while checking if the number is the lowest.  
O(n log n) merge sort  
  
also, the linear search can be O(n)



Brute force -> Naïve( can also be optimal but can be even more optimize)  -> Greedy algorithm(somewhat Optimal approach) -> Optimal approach(true optimal) 

Tend to be linear in work and may include sorting   

A greedy algorithm is a simple, intuitive algorithm that follows the problem-solving heuristic(any approach) of making the locally optimal choice at each stage of the algorithm to get an overall optimal solution. 

However, in many problems, a greedy strategy does not produce an optimal solution. It is very simple quick and easy to code and is considered optimal in terms of making the first immediate optimal choice but not accessing the overall optimal approach that is why it can be bad but sometimes can be okay for simple straight forward problems