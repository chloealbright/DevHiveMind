{
	"nodes":[
		{"id":"6f5c525180d5cafa","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Search Algorithms </h4>\n</center>\n\n","x":-2240,"y":-1580,"width":1480,"height":368,"color":"1"},
		{"id":"c39e7d606352765d","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Binary Search </h4>\n</center>\n\n","x":-2160,"y":-1129,"width":480,"height":150},
		{"id":"c841a2ae62c2b4ff","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc704.png","x":-2120,"y":-917,"width":400,"height":292},
		{"id":"54ce953fba4f3920","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Linear Search </h4>\n</center>\n\n","x":-1378,"y":-1129,"width":480,"height":150},
		{"id":"ea2d6ab5a12b24df","type":"text","text":"```javascript\nfunction indexEqualsValueSearch(arr) {\n    let low = 0;\n    let mid = arr.length / 2;\n    let min = Infinity;\n\n    for (let start = 0; start < arr.length; ++start) {\n        if (arr[start] === start) {\n            min = Math.min(min, arr[start]);\n        }\n    }\n\n    return min === Infinity ? -1 : min;\n    // Check current index and value to see if they match and find the lowest matching value\n}\n```","x":-1428,"y":-930,"width":580,"height":391},
		{"id":"2459f85bc43b1ae7","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc744.png","x":-2120,"y":-539,"width":400,"height":187},
		{"id":"98642a5104772367","type":"text","text":"Both expressions calculate the middle index of a range, but they are used in different contexts and for different scenarios.\n\n1. **`let mid = Math.floor((low + high) / 2);`**\n\n   This is the standard calculation for the middle index in a binary search or any situation where you want to find the midpoint of a range between two indices (`low` and `high`). This formula works well when you are dealing with the current range and want to split it into two halves.\n\n   ```javascript\n   let mid = Math.floor((low + high) / 2);\n   ```\n\n2. **`let mid = left + Math.floor((right - left + 1) / 2);`**\n\n   This formula is used in certain situations where you want to find the midpoint in a specific way. It is often employed in algorithms where you need to adjust the calculation to suit the problem's requirements. The `+1` in the formula ensures that the midpoint leans towards the right if the range has an odd number of elements.\n\n   ```javascript\n   let mid = left + Math.floor((right - left + 1) / 2);\n   ```\n\n   This might be used in scenarios where you are working with subarrays, or when you need to adjust the midpoint calculation for the specific requirements of a particular algorithm.\n\nIn summary, both formulas find the middle index of a range, but the second formula (`left + Math.floor((right - left + 1) / 2)`) is more specific and may be used in certain situations where the standard binary search formula might need adaptation for the problem at hand.","x":-2240,"y":-293,"width":658,"height":983},
		{"id":"024d6f69002962f1","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/treeStruc.png","x":-1648,"y":-3008,"width":192,"height":400},
		{"id":"64266aa511d2f43f","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/Backtrack.png","x":-1552,"y":-3349,"width":399,"height":269},
		{"id":"58dce0795bb8195e","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc904.png","x":-848,"y":-3007,"width":363,"height":400},
		{"id":"8168d5c760f807a7","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc986.png","x":-1288,"y":-2434,"width":400,"height":153},
		{"id":"d2f61c51528b4017","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc904.png","x":-848,"y":-3520,"width":363,"height":400},
		{"id":"b475b69ad0b48a91","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc49.png","x":-1847,"y":-2485,"width":399,"height":256},
		{"id":"bc13b26f518aa299","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc2.png","x":-2168,"y":-2808,"width":400,"height":257},
		{"id":"b87e56d11a150d4e","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc3nw.png","x":-666,"y":-2454,"width":400,"height":193},
		{"id":"b488f7f1cb2f78d2","type":"text","text":"<center>\n  <h4 style=\"font-size: 50px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Optimal Sorts </h4>\n</center>\n\n","x":-485,"y":-1129,"width":880,"height":150},
		{"id":"38b7ed365001f13c","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc268.png","x":555,"y":-916,"width":400,"height":291},
		{"id":"993171a88d1c6138","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/mergeSort.png","x":-485,"y":-884,"width":400,"height":259},
		{"id":"216ae97b8ef097ba","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/quicksort.png","x":-5,"y":-862,"width":399,"height":216},
		{"id":"dae54ad49aa9ec97","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc448.png","x":555,"y":-528,"width":400,"height":246},
		{"id":"3f5c84e1e2d80ce6","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Sort Algorithms </h4>\n</center>\n\n","x":-485,"y":-1569,"width":1480,"height":368,"color":"2"},
		{"id":"986759463ed39fa2","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Pointer Manipulation</h4>\n</center>\n\n","x":1200,"y":-1569,"width":1466,"height":368,"color":"3"},
		{"id":"26c526b16b714c0a","type":"text","text":"\n# [[Key Base Attributes of  Grokking Algorithm patterns#Two Pointer |Two Pointer]] \n\n\n","x":1320,"y":-1077,"width":294,"height":75},
		{"id":"7875257352e32714","type":"text","text":"# Fast slow is basically a variation of two pointer used for detecting cycles in two pointer","x":1694,"y":-1149,"width":479,"height":294},
		{"id":"b989aa10916de99d","type":"text","text":"# [[Key Base Attributes of  Grokking Algorithm patterns#Fast & Slow Pointers |Fast Slow Pointer]]","x":2214,"y":-1077,"width":486,"height":75},
		{"id":"5599748caa5a7cf8","type":"text","text":"# [[Key Base Attributes of  Grokking Algorithm patterns#Cyclic Sort |Cyclic Sort]]","x":593,"y":-1129,"width":325,"height":90},
		{"id":"089443a65f001f43","type":"text","text":"##### Modified binary search is just a variation of the core binary search structure also default to while loop for this search","x":-2540,"y":-1054,"width":360,"height":374}
	],
	"edges":[
		{"id":"87b81ddd507e6712","fromNode":"26c526b16b714c0a","fromSide":"right","toNode":"b989aa10916de99d","toSide":"left"}
	]
}