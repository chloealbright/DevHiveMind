---
tags: 
author:
  - jacgit18
Status: 
Started: 
EditDate: 
Relates: 
Comments:
---
```typescript
function twoSum(nums: number[], target: number): number[] {
    // Step 1
    const numMap: Record<number, number> = {};

    // Step 2
    for (let i = 0; i < nums.length; i++) {
        // Step 3
        const complement = target - nums[i];

        // Step 4
        if (complement in numMap) {
            // Step 5
            return [numMap[complement], i];
        }

        // Step 6
        numMap[nums[i]] = i;
    }

    // Step 7
    throw new Error("No valid solution found");
}

// Step 8: Example Usage
const nums1 = [2, 7, 11, 15];
const target1 = 9;
console.log(twoSum(nums1, target1)); // Output: [0, 1]

// Repeat Step 8 for other examples...
```

## Steps

1. **Initialize a Hash Map**: Create an empty hash map to store the indices of elements.

2. **Loop through the Array**: Iterate through the given array of numbers.

3. **Calculate Complement**: For each element in the array, calculate the complement by subtracting it from the target.

4. **Check if Complement in Map**: Check if the complement is already present in the hash map.

5. **Return Indices if Found**: If the complement is in the map, return the indices of the current element and the complement.

6. **Store Current Element in Map**: If the complement is not in the map, store the current element along with its index in the hash map.

7. **Handle No Solution**: If the loop completes without finding a solution, throw an error indicating that no valid solution was found.

8. **Example Usage**: Use the function with example arrays and targets to verify its correctness.





given this problem what key areas you see that aligns with Big O actions like Access, Search, Insertion, and Deletion

This problem seems related to searching for pairs that sum up to a target in a list. In terms of Big O actions:

1. **Access**: Accessing individual elements in the list during the search process.

2. **Search**: Searching for pairs involves going through the entire list.

3. **Insertion**: No explicit insertion is mentioned, so this might not be applicable.

4. **Deletion**: No explicit deletion is mentioned, so this might not be applicable.

The primary focus appears to be on accessing and searching elements in the list as you look for pairs that meet the criteria.




## Plain English Steps 

1. **Prepare for Tracking**: Imagine setting up a system to keep track of numbers and their positions.

2. **Look Through the List**: Go through the list of numbers one by one.

3. **Find a Pairing Strategy**: For each number, figure out another number that, when combined, equals the target sum.

4. **Check if You've Seen It Before**: See if you've encountered this special number before in your journey.

5. **Declare Success if Found**: If you've seen it before, celebrate! You've found two numbers that add up to the target.

6. **Remember for the Future**: If this special number is new, make a mental note of it for future reference.

7. **Express Failure if Nothing Works**: If you go through the whole list without finding a solution, admit that it seems impossible in this case.




## Plain English user story broken into CRUD 


**Create:**
1. **Prepare for Tracking**: As a problem solver, I want to create a system with variables to keep track of numbers and their positions.

**Read:**
2. **Look Through the List**: As a problem solver, I want to read through a list of numbers stored in a variable, one by one.
3. **Find a Pairing Strategy**: As a problem solver, I want to read each number from the variable and determine another number that, when combined, equals the target sum.
4. **Check if You've Seen It Before**: As a problem solver, I want to read and check if a specific number from the variable has been encountered before during my journey.

**Update:**
5. **Declare Success if Found**: As a problem solver, I want to update the status by declaring success if I've seen the special number before, acknowledging that I've found two numbers that add up to the target.
6. **Remember for the Future**: As a problem solver, I want to update my memory (variable) by making a mental note of a new special number for future reference.

**Delete (or Handle Failure):**
7. **Express Failure if Nothing Works**: As a problem solver, I want to handle failure by expressing that it seems impossible to find a solution in this case.



Create:
1. Initialize variables to track numbers and their positions.

Read:
2. Iterate through a list of numbers stored in a variable.
3. Determine a pairing strategy by finding another number that, when combined, equals the target sum.
4. Check if the current number has been encountered before.

Update:
5. Declare success if a pair with the target sum is found.
6. Update memory by noting a new special number for future reference.

Delete (or Handle Failure):
7. Express failure if no solution is found during the process.

