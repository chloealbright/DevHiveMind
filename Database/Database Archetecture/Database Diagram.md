![[DB UML relationship types.jpeg]]

primary can't be changed or repeated in the entity diagram 

Primary Key: Is a single field chosen by the designer to uniquely identify a record in a table (relation), cannot be null (empty/unassigned). 

Foreign Key: Is the Primary Key from one table cross-referenced on another table. 

Secondary (or Alternative) Key: Is any field in the table that isn't selected to be any of the two types above. 

Let's take a look at the one-to-many relationship. This is the most common type of relationship that databases use. It connects one piece of data, one row of a table to one or more other pieces of data. This relationship is represented by a line that looks like this. One endpoint for the one side of the relationship to a little symbol called a crow's foot, representing many endpoints. Let's consider our Customers table and our Dishes table here for a moment. We want to represent our customer's favorite dish in the Customers table. For each customer, we would write the name of the dish in the FavoriteDish column. But this is a lot of work, and if we ever change the name of a dish, maybe if we notice a spelling error in our Dishes table, we'd need to be conscientious and update the name in our Customers table as well. In a small database, this may not be a huge problem, but in a large database, this kind of hands-on maintenance and administration would quickly become a time-consuming problem to solve, and a major issue for the consistency and integrity of our data. Instead, we'll use the primary key for the dish to represent data in the customer table. Using the key has a few advantages, the key never changes and is guaranteed to be unique. It also has the benefit of taking up much less space than a full-text name, which helps keep the database smaller as more entries are added. We use a one-to-many relationship here because one dish may be the favorite of many customers. And so this looks like many-to-one. Many customers to one dish. In the one-to-many relationship, the foreign key will be on the many side. The dish ID is a foreign key in the FavoriteDish column of the Customers table, so this relationship is one dish to many customers, and so it's a one-to-many. Regardless of the direction that the relationship appears on paper or in a diagram, it's still a one-to-many. There's not really a separate thing called a many-to-one relationship. It's just a matter of how you look at it. Now, our favorite dish column has a piece of information that represents a whole row in the Dishes table, and we don't have to worry about changes there causing problems we'll need to fix or update to maintain the integrity of our data. We can also use this relationship to model other connections between items. To keep track of reservations, we'd have an entry for each reservation in a dedicated table. And in the Customer column, we'd put the key for the Customers entry in the Customers table. Each reservation will have one customer, but one customer might have many reservations, at least we hope they will. Using a one-to-many relationship doesn't require the many end to have a lot of instances. There could just be two different values on the many side, or even one. The point is that this relationship allows one record to be associated with many records.

![[GetImage (27).png]]

 Many orders could have many dishes and many dishes could be included in many orders. This is what we draw when we discover that we need this kind of relationship, a line with a crow's foot on each end. And that's a signal to us that we need to do a little more work. In most DBMS tools, we can't model a many-to-many relationship directly, so we need to create a linking table, which has a one-to-many relationship with both of the tables we want to use. We'll name it orders dishes. These linking tables are customarily named by combining the table on the left of the many-to-many relationship with the name of the table on the right. The linking table only needs two columns, an order ID and a dish ID. For each item in an order, we'll add a row for each dish. Then when we want to call up information about a customer's orders, we'll ask the database for rows matching the order numbers, and we'll get back a list of the dishes, or rather, the dish IDs that were part of each order. It could be just one or it could be five, 10, or 50. Doing this keeps our orders table nice and clean while allowing us to record the details of what each order included. And it also let's us easily find out how many orders a particular dish was included in. We could create other many-to-many relationships using linking tables for other associations, like if we wanted to keep track of many dishes that a customer likes, we might make a customers dishes table, or if we had a list of ingredients or allergens, we could create a dishes ingredients table or a dishes allergens table, so we could have that information at our fingertips for printing up detailed menus or adding warnings to entries on the menu for someone who might be allergic to an ingredient. We could also model a customer's events linking table. If a customer attends or is interested in attending various events offered throughout the year. Like the previous linking table, this would involve just a customer ID and an event ID with one row for each event the customer plants to attend. And in building this, we'll also be able to get a list of which events specific customers are interested in to help us with our planning. Many-to-many relationships are fairly common, but they're really made up of one-to-many relationships with the addition of a linking table. As you model your database, keep in mind that you might need to add in some linking tables to fulfill certain relationships. Remember, designing a database with ER diagrams is an iterative process. You don't have to get it just right on the first try. 

one-to-one. This is not frequently used, because usually if there's only one row that associates with only one other row, it suggests that the two rows should just be one row and one table. Our database here doesn't have anything that needs a one-to-one relationship. But a real-world example of a one-to-one relationship involves security. We could separate our customers table into two tables, putting just the customers' name and ID in one table and their personal information in the other. Then we'd have a one-to-one relationship between the tables. We might choose to protect the customers' personal information, like their birthday or email address, from being viewed by our employees, while leaving their name and key available to use in other relationships, like printing place cards or looking up a reservation. We might also use a one-to-one relationship if we were assigning resources of some kind, like aprons or chef's hats or iPads, from a table of equipment. If we assign one item to one person, it's not available to be assigned to another person. And one person couldn't be assigned more than one item. Chances are in a real-life scenario, you'd handle equipment assignment differently than this, but that's another way to think about it. One-to-one relationships are indicated by a line with just one endpoint on either side. Some DBMS tools will allow you to secure individual columns of data. So, depending on your implementation, building a relationship like this may not be necessary to protect information. It certainly makes more sense to keep related information together, but various restrictions might require you to separate information. Doing so is an example of denormalization, as we'll see in a little bit. 

referential integrity, which means the database will be aware of the relationship and will not let you or another user modify data in a way that violates that relationship. This helps us to maintain the consistency of the database.


![[GetImage (28).png]]


![[GetImage (29).png]]

