{
	"nodes":[
		{"id":"994b9d81037cb7c4","type":"group","x":5800,"y":399,"width":3240,"height":2362,"label":"Merging List"},
		{"id":"8675754d1ace9424","type":"group","x":9040,"y":-2384,"width":2760,"height":2320,"label":"Dynamic programming"},
		{"id":"c46f5531386ed038","type":"group","x":3200,"y":-2384,"width":2600,"height":2320,"label":"Backtracking"},
		{"id":"dafe625fdcaa6bdc","type":"group","x":6320,"y":-2384,"width":2240,"height":2320,"label":"Sliding window"},
		{"id":"af497f0dfb13495a","type":"group","x":1200,"y":-2384,"width":1800,"height":2783,"label":"Pointer"},
		{"id":"0db2556051b59796","type":"group","x":3200,"y":263,"width":2179,"height":2057,"label":"Finding¬† Smallest or Largest Elements¬†"},
		{"id":"2e4f2058c518e9cb","type":"group","x":480,"y":840,"width":2120,"height":1920,"label":"Untitled group"},
		{"id":"8a23eac4851dd237","type":"text","text":"Dynamic programming is a problem-solving technique used to solve optimization problems by breaking them down into smaller overlapping subproblems. The knapsack problem is a classic optimization problem that can be efficiently solved using dynamic programming.\n\nIn the context of the knapsack problem, dynamic programming involves solving smaller subproblems and using their solutions to build up the solution for the larger problem. The knapsack problem often has two variations: 0/1 Knapsack, where items can either be included or excluded, and Fractional Knapsack, where items can be divided.\n\nDynamic programming helps optimize the solution to the knapsack problem by avoiding redundant computations. By storing and reusing solutions to subproblems, dynamic programming ensures an efficient solution to the overall problem. This approach significantly improves the time complexity compared to naive recursive approaches, making it a powerful tool for solving various types of optimization problems, including the knapsack problem.","x":11200,"y":-1720,"width":459,"height":1509},
		{"id":"26831e9333011dd0","type":"text","text":"The reason why **\"Access\"** should be included, even though it's a subset of **\"Reads\"**, lies in the nuanced requirements of certain problems. While performing tasks like searching or implementing conditional logic, you may indeed engage in **\"Access\"** operations. However, when addressing traversal-related challenges, a full traversal of a specific data structure or path might not always be necessary. In scenarios like backtracking problems, you might find that performing a sub-action like **\"Access\"** suffices. For instance, consider a problem where you need to traverse a matrix in a **spiral** manner. In such cases, you're primarily accessing adjacent elements without necessarily reading the entire matrix. Therefore, including **\"Access\"** as a separate category of actions ensures comprehensive coverage when analyzing and solving problems. üåÄüîç","x":3465,"y":-935,"width":575,"height":831},
		{"id":"2014bccb5492caa0","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\"> Element Selection </h4>\n</center>\n\n","x":3360,"y":682,"width":1819,"height":368,"color":"5"},
		{"id":"d48c234c57a6a567","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Top K Elements]]","x":3712,"y":1214,"width":788,"height":586},
		{"id":"e967e089016e94ad","type":"text","text":"#### Function Structure:\n\nThis structure allows you to explore different paths in a matrix or graph, checking right, left, down, and up directions. It keeps track of visited positions and backtracks as needed.\n\n#### Additional Techniques:\n- You can use closure to create a function that takes in a matrix and returns an inner function with parameters for the current row and column values.\n- You can start the traversal from different roots in the matrix depending on your problem requirements.\n- The order of traversal can vary depending on the problem and can be customized to suit your needs.","x":4627,"y":-1327,"width":752,"height":718},
		{"id":"e69057eef2914fe4","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Backtracking/Subset </h4>\n</center>\n\n","x":3560,"y":-1857,"width":1819,"height":368,"color":"5"},
		{"id":"e8f5daa45271cd68","type":"text","text":"# [[Key Base Attributes of  Grokking Algorithm patterns#Subsets/Backtracking |Backtracking]]","x":4172,"y":-1423,"width":343,"height":116},
		{"id":"64266aa511d2f43f","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/Backtrack Robo Path.png","x":4172,"y":-1258,"width":399,"height":269},
		{"id":"f934c03c7940f169","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Range Processing </h4>\n</center>\n\n","x":6561,"y":-1857,"width":1819,"height":368,"color":"5"},
		{"id":"1f3da6aa99e9ff5e","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Sliding Window |Sliding Window]]","x":6795,"y":-1393,"width":1040,"height":619},
		{"id":"26c526b16b714c0a","type":"text","text":"\n![[Key Base Attributes of  Grokking Algorithm patterns#Two Pointer |Two Pointer]] \n\n\n","x":1240,"y":-1388,"width":454,"height":314},
		{"id":"7875257352e32714","type":"text","text":"# Fast slow is basically a variation of two pointer used for detecting cycles in two pointer","x":1760,"y":-1453,"width":533,"height":309},
		{"id":"dcda9c3dcef382a3","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Reversing a Linked List |Reversing a Linked List]]","x":2027,"y":-1003,"width":709,"height":459},
		{"id":"b989aa10916de99d","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Fast & Slow Pointers |Fast Slow Pointer]]","x":2334,"y":-1381,"width":626,"height":237},
		{"id":"986759463ed39fa2","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Pointer Manipulation</h4>\n</center>\n\n","x":1320,"y":-1873,"width":1466,"height":368,"color":"3"},
		{"id":"b87e56d11a150d4e","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc3nw.png","x":6795,"y":-665,"width":1077,"height":520},
		{"id":"9287d7f5fc1ea5b2","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc1721.png","x":2182,"y":-342,"width":400,"height":383},
		{"id":"024d6f69002962f1","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/treeStruc.png","x":1140,"y":889,"width":192,"height":400},
		{"id":"d2f61c51528b4017","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc904.png","x":1916,"y":920,"width":363,"height":400},
		{"id":"3c0afbd524e9bc10","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/Linked List to Tree to Graph.png","x":1600,"y":1451,"width":826,"height":564},
		{"id":"3c04c53a128b891a","type":"text","text":"# Used for comparing range of elements next to each other ","x":7872,"y":-1365,"width":448,"height":216},
		{"id":"612516827fa1ecaa","type":"text","text":"In Place Sort Two pointers","x":1444,"y":-960,"width":456,"height":60},
		{"id":"8168d5c760f807a7","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc986.png","x":6545,"y":1050,"width":1275,"height":487},
		{"id":"e19264637f4761fe","type":"text","text":"# a dummy node is an artificial or placeholder node added to the list for various purposes, often to simplify edge cases or improve the efficiency of certain operations.","x":1280,"y":-773,"width":620,"height":344},
		{"id":"a3ed95bc6e5747ce","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Merge Algorithms </h4>\n</center>\n\n","x":6386,"y":580,"width":1819,"height":368,"color":"5"},
		{"id":"aaca24c0521f9659","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc1721ALT.png","x":1620,"y":-331,"width":400,"height":361},
		{"id":"30d70d92b9d56c19","type":"text","text":"![[Destructuring Value Swap]]","x":6250,"y":1760,"width":1084,"height":946},
		{"id":"241d1f208b414dee","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#K-Way Merge]]","x":8000,"y":1070,"width":900,"height":447},
		{"id":"70b42aa53a799b1a","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Merge Intervals]]","x":8000,"y":1585,"width":885,"height":447},
		{"id":"5ffbc2cb21f1ccb2","type":"text","text":"# [[Dynamic programming Patterns]]","x":9942,"y":-1505,"width":458,"height":105},
		{"id":"b09e420decafa819","type":"text","text":"<center>\n  <h4 style=\"font-size: 120px; -webkit-text-stroke: 1px green; -webkit-text-fill-color: transparent;\">Optimization Patterns </h4>\n</center>\n\n","x":9280,"y":-2041,"width":1819,"height":368,"color":"5"},
		{"id":"b675d7261c9bba2a","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Dynamic Programming]]","x":9560,"y":-1274,"width":840,"height":445},
		{"id":"3c4c48fca3bb1da1","type":"text","text":"![[Key Base Attributes of  Grokking Algorithm patterns#Knapsack Problem]]","x":10523,"y":-1274,"width":576,"height":434},
		{"id":"b8b0c34c19433cfa","type":"text","text":"# [[Knapsack Pattern]]","x":10588,"y":-1505,"width":511,"height":132},
		{"id":"5da5bfee0690f377","type":"text","text":"## Keyword indicator \n**Dynamic Programming:** Keywords like \"optimal substructure,\" \"overlapping subproblems,\" or explicit mentions of finding the \"best,\" \"maximum,\" or \"minimum\" solution over a set of choices.","x":9889,"y":-708,"width":699,"height":268},
		{"id":"bc13b26f518aa299","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc2.png","x":640,"y":940,"width":400,"height":257},
		{"id":"8a695e44195c85af","type":"text","text":"## Problem Statement phrasing used to Identify potential pattern","x":-440,"y":1040,"width":714,"height":498},
		{"id":"b475b69ad0b48a91","type":"file","file":"Algorithms & Data Structures/_Coding Whiteboard/lc49.png","x":660,"y":1240,"width":399,"height":256},
		{"id":"d37054d16ee85952","type":"link","url":"https://algo.monster/flowchart","x":-2605,"y":1760,"width":2125,"height":3481},
		{"id":"204903a50deeb9ad","type":"text","text":"```javascript  \nclass ListNode {  \nconstructor(value) {  \nthis.value = value;  \n[this.next](http://this.next/) = null;  \n}  \n}  \n  \nfunction arrayToLinkedList(array) {  \nif (array.length === 0) {  \nreturn null;  \n}  \n  \nlet head = new ListNode(array[0]);  \nlet current = head;  \nlet i = 1;  \n  \nwhile (i < array.length) {  \n[current.next](http://current.next/) = new ListNode(array[i]);  \ncurrent = current.next;  \ni++;  \n}  \n  \nreturn head;  \n}  \n  \n// Example usage:  \nconst inputArray = [1, 2, 3, 4, 5];  \nconst linkedList = arrayToLinkedList(inputArray);  \nconsole.log(linkedList);  \n```","x":620,"y":1660,"width":760,"height":980},
		{"id":"0d4345a71bba6971","type":"file","file":"Algorithms & Data Structures/_Infographic/Patterns path.png","x":1760,"y":2960,"width":6240,"height":3501}
	],
	"edges":[
		{"id":"87b81ddd507e6712","fromNode":"26c526b16b714c0a","fromSide":"right","toNode":"b989aa10916de99d","toSide":"left"}
	]
}